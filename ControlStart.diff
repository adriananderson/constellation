diff --git a/control.go b/control.go
index e16d07d..fa0e873 100644
--- a/control.go
+++ b/control.go
@@ -13,9 +13,15 @@ import (
 // Every interaction here needs to take extra care to copy memory and not return or use arguments "as is" when touching
 // core. This means copying IP objects, slices, de-referencing pointers and taking the actual value, etc
 
+// StartFunc accepts no arguments and returns nothing. Different services can use this to register
+// work to execute after the Interface is activated by appending their specific calls to the Control.sf field.
+// Control.Start() will invoke each function in its own goroutine, so it can be a blocking call or not.
+type StartFunc func()
+
 type Control struct {
-	f *Interface
-	l *logrus.Logger
+	f  *Interface
+	l  *logrus.Logger
+	sf []StartFunc // funcs to execute after the interface is created.
 }
 
 type ControlHostInfo struct {
@@ -31,6 +37,19 @@ type ControlHostInfo struct {
 
 // Start actually runs nebula, this is a nonblocking call. To block use Control.ShutdownBlock()
 func (c *Control) Start() {
+	// Activate the interface
+	c.f.activate()
+
+	// Call all the delayed funcs that waited patiently for the interface to be created.
+	for _, callMe := range c.sf {
+		if callMe != nil {
+			go callMe()
+		}
+	}
+	// Let the GC know we don't need these things anymore.
+	c.sf = nil
+
+	// Start reading packets.
 	c.f.run()
 }
 
diff --git a/dns_server.go b/dns_server.go
index 3fec6b6..d57a9c0 100644
--- a/dns_server.go
+++ b/dns_server.go
@@ -108,14 +108,19 @@ func handleDnsRequest(w dns.ResponseWriter, r *dns.Msg) {
 	w.WriteMsg(m)
 }
 
-func dnsMain(hostMap *HostMap, c *Config) {
+// dnsMain initializes the global dnsR, which must happen before anyone tries to use it.
+// It returns a function that callers must invoke to serve DNS.
+func dnsMain(hostMap *HostMap, c *Config) StartFunc {
 	dnsR = newDnsRecords(hostMap)
 
 	// attach request handler func
 	dns.HandleFunc(".", handleDnsRequest)
 
 	c.RegisterReloadCallback(reloadDns)
-	startDns(c)
+
+	return func() {
+		startDns(c)
+	}
 }
 
 func getDnsServerAddr(c *Config) string {
diff --git a/interface.go b/interface.go
index ee90657..977dc0a 100644
--- a/interface.go
+++ b/interface.go
@@ -107,7 +107,10 @@ func NewInterface(c *InterfaceConfig) (*Interface, error) {
 	return ifce, nil
 }
 
-func (f *Interface) run() {
+// activate creates the interface on the host. After the interface is created, any
+// other services that want to bind listeners to its IP may do so successfully. However,
+// the interface isn't going to process anything until run() is called.
+func (f *Interface) activate() {
 	// actually turn on tun dev
 	if err := f.inside.Activate(); err != nil {
 		l.Fatal(err)
@@ -121,7 +124,9 @@ func (f *Interface) run() {
 	l.WithField("interface", f.inside.DeviceName()).WithField("network", f.inside.CidrNet().String()).
 		WithField("build", f.version).WithField("udpAddr", addr).
 		Info("Nebula interface is active")
+}
 
+func (f *Interface) run() {
 	// Launch n queues to read packets from udp
 	for i := 0; i < f.udpQueues; i++ {
 		go f.listenOut(i)
diff --git a/main.go b/main.go
index 73ec8e7..7c3af11 100644
--- a/main.go
+++ b/main.go
@@ -24,6 +24,7 @@ func Main(config *Config, configTest bool, buildVersion string, logger *logrus.L
 		FullTimestamp: true,
 	}
 
+	startupCbs := make([]StartFunc, 0, 3)
 	// Print the config if in test, the exit comes later
 	if configTest {
 		b, err := yaml.Marshal(config.Settings)
@@ -82,10 +83,13 @@ func Main(config *Config, configTest bool, buildVersion string, logger *logrus.L
 	ssh, err := sshd.NewSSHServer(l.WithField("subsystem", "sshd"))
 	wireSSHReload(ssh, config)
 	if config.GetBool("sshd.enabled", false) {
-		err = configSSH(ssh, config)
+		sshRun, err := configSSH(ssh, config)
 		if err != nil {
 			return nil, NewContextualError("Error while configuring the sshd", nil, err)
 		}
+		if sshRun != nil {
+			startupCbs = append(startupCbs, sshRun)
+		}
 	}
 
 	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@@ -357,10 +361,13 @@ func Main(config *Config, configTest bool, buildVersion string, logger *logrus.L
 		go lightHouse.LhUpdateWorker(ifce)
 	}
 
-	err = startStats(config, configTest)
+	statsCb, err := startStats(config, configTest)
 	if err != nil {
 		return nil, NewContextualError("Failed to start stats emitter", nil, err)
 	}
+	if statsCb != nil {
+		startupCbs = append(startupCbs, statsCb)
+	}
 
 	if configTest {
 		return nil, nil
@@ -374,8 +381,11 @@ func Main(config *Config, configTest bool, buildVersion string, logger *logrus.L
 	// Start DNS server last to allow using the nebula IP as lighthouse.dns.host
 	if amLighthouse && serveDns {
 		l.Debugln("Starting dns server")
-		go dnsMain(hostMap, config)
+		dnsCb := dnsMain(hostMap, config)
+		if dnsCb != nil {
+			startupCbs = append(startupCbs, dnsCb)
+		}
 	}
 
-	return &Control{ifce, l}, nil
+	return &Control{ifce, l, startupCbs}, nil
 }
diff --git a/ssh.go b/ssh.go
index 9e409bc..db4a6a6 100644
--- a/ssh.go
+++ b/ssh.go
@@ -46,48 +46,55 @@ type sshCreateTunnelFlags struct {
 func wireSSHReload(ssh *sshd.SSHServer, c *Config) {
 	c.RegisterReloadCallback(func(c *Config) {
 		if c.GetBool("sshd.enabled", false) {
-			err := configSSH(ssh, c)
+			sshRun, err := configSSH(ssh, c)
 			if err != nil {
 				l.WithError(err).Error("Failed to reconfigure the sshd")
 				ssh.Stop()
 			}
+			if sshRun != nil {
+				go sshRun()
+			}
 		} else {
 			ssh.Stop()
 		}
 	})
 }
 
-func configSSH(ssh *sshd.SSHServer, c *Config) error {
+// configSSH reads the ssh info out of the passed-in Config and
+// updates the passed-in SSHServer. On success, it returns a function
+// that callers may invoke to run the configured ssh server. On
+// failure, it returns nil, error.
+func configSSH(ssh *sshd.SSHServer, c *Config) (StartFunc, error) {
 	//TODO conntrack list
 	//TODO print firewall rules or hash?
 
 	listen := c.GetString("sshd.listen", "")
 	if listen == "" {
-		return fmt.Errorf("sshd.listen must be provided")
+		return nil, fmt.Errorf("sshd.listen must be provided")
 	}
 
 	_, port, err := net.SplitHostPort(listen)
 	if err != nil {
-		return fmt.Errorf("invalid sshd.listen address: %s", err)
+		return nil, fmt.Errorf("invalid sshd.listen address: %s", err)
 	}
 	if port == "22" {
-		return fmt.Errorf("sshd.listen can not use port 22")
+		return nil, fmt.Errorf("sshd.listen can not use port 22")
 	}
 
 	//TODO: no good way to reload this right now
 	hostKeyFile := c.GetString("sshd.host_key", "")
 	if hostKeyFile == "" {
-		return fmt.Errorf("sshd.host_key must be provided")
+		return nil, fmt.Errorf("sshd.host_key must be provided")
 	}
 
 	hostKeyBytes, err := ioutil.ReadFile(hostKeyFile)
 	if err != nil {
-		return fmt.Errorf("error while loading sshd.host_key file: %s", err)
+		return nil, fmt.Errorf("error while loading sshd.host_key file: %s", err)
 	}
 
 	err = ssh.SetHostKey(hostKeyBytes)
 	if err != nil {
-		return fmt.Errorf("error while adding sshd.host_key: %s", err)
+		return nil, fmt.Errorf("error while adding sshd.host_key: %s", err)
 	}
 
 	rawKeys := c.Get("sshd.authorized_users")
@@ -138,14 +145,15 @@ func configSSH(ssh *sshd.SSHServer, c *Config) error {
 		l.Info("no ssh users to authorize")
 	}
 
+	var runner func()
 	if c.GetBool("sshd.enabled", false) {
 		ssh.Stop()
-		go ssh.Run(listen)
+		runner = func() { ssh.Run(listen) }
 	} else {
 		ssh.Stop()
 	}
 
-	return nil
+	return runner, nil
 }
 
 func attachCommands(ssh *sshd.SSHServer, hostMap *HostMap, pendingHostMap *HostMap, lightHouse *LightHouse, ifce *Interface) {
diff --git a/sshd/server.go b/sshd/server.go
index 7f6da3b..20095dc 100644
--- a/sshd/server.go
+++ b/sshd/server.go
@@ -93,6 +93,7 @@ func (s *SSHServer) Run(addr string) error {
 	var err error
 	s.listener, err = net.Listen("tcp", addr)
 	if err != nil {
+		s.l.WithField("err", err).Warn("Error starting SSH server listener, shutting down")
 		return err
 	}
 
@@ -141,21 +142,20 @@ func (s *SSHServer) Run(addr string) error {
 }
 
 func (s *SSHServer) Stop() {
-	for _, c := range s.conns {
-		c.Close()
-	}
-
-	if s.listener == nil {
-		return
+	// Close the listener first, to prevent any new connections being accepted.
+	if s.listener != nil {
+		if err := s.listener.Close(); err != nil {
+			s.l.WithError(err).Warn("Failed to close the sshd listener")
+		} else {
+			s.l.Info("SSH server stopped listening")
+		}
 	}
 
-	err := s.listener.Close()
-	if err != nil {
-		s.l.WithError(err).Warn("Failed to close the sshd listener")
-		return
+	// Force close all existing connections.
+	for _, c := range s.conns {
+		c.Close()
 	}
 
-	s.l.Info("SSH server stopped listening")
 	return
 }
 
diff --git a/stats.go b/stats.go
index fec1189..29d8e15 100644
--- a/stats.go
+++ b/stats.go
@@ -15,15 +15,18 @@ import (
 	"github.com/rcrowley/go-metrics"
 )
 
-func startStats(c *Config, configTest bool) error {
+// startStats initializes stats from config. On success, if any futher work
+// is needed to serve stats, it returns a func to handle that work. If no
+// work is needed, it'll return nil. On failure, it returns nil, error.
+func startStats(c *Config, configTest bool) (StartFunc, error) {
 	mType := c.GetString("stats.type", "")
 	if mType == "" || mType == "none" {
-		return nil
+		return nil, nil
 	}
 
 	interval := c.GetDuration("stats.interval", 0)
 	if interval == 0 {
-		return fmt.Errorf("stats.interval was an invalid duration: %s", c.GetString("stats.interval", ""))
+		return nil, fmt.Errorf("stats.interval was an invalid duration: %s", c.GetString("stats.interval", ""))
 	}
 
 	switch mType {
@@ -32,16 +35,16 @@ func startStats(c *Config, configTest bool) error {
 	case "prometheus":
 		startPrometheusStats(interval, c, configTest)
 	default:
-		return fmt.Errorf("stats.type was not understood: %s", mType)
+		return nil, fmt.Errorf("stats.type was not understood: %s", mType)
 	}
 
 	metrics.RegisterDebugGCStats(metrics.DefaultRegistry)
 	metrics.RegisterRuntimeMemStats(metrics.DefaultRegistry)
 
-	go metrics.CaptureDebugGCStats(metrics.DefaultRegistry, interval)
-	go metrics.CaptureRuntimeMemStats(metrics.DefaultRegistry, interval)
-
-	return nil
+	return func() {
+		go metrics.CaptureDebugGCStats(metrics.DefaultRegistry, interval)
+		go metrics.CaptureRuntimeMemStats(metrics.DefaultRegistry, interval)
+	}, nil
 }
 
 func startGraphiteStats(i time.Duration, c *Config, configTest bool) error {
