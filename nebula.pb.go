// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nebula.proto

package nebula

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NebulaMeta_MessageType int32

const (
	NebulaMeta_None                   NebulaMeta_MessageType = 0
	NebulaMeta_HostQuery              NebulaMeta_MessageType = 1
	NebulaMeta_HostQueryReply         NebulaMeta_MessageType = 2
	NebulaMeta_HostUpdateNotification NebulaMeta_MessageType = 3
	NebulaMeta_HostMovedNotification  NebulaMeta_MessageType = 4
	NebulaMeta_HostPunchNotification  NebulaMeta_MessageType = 5
	NebulaMeta_HostWhoami             NebulaMeta_MessageType = 6
	NebulaMeta_HostWhoamiReply        NebulaMeta_MessageType = 7
	NebulaMeta_PathCheck              NebulaMeta_MessageType = 8
	NebulaMeta_PathCheckReply         NebulaMeta_MessageType = 9
)

var NebulaMeta_MessageType_name = map[int32]string{
	0: "None",
	1: "HostQuery",
	2: "HostQueryReply",
	3: "HostUpdateNotification",
	4: "HostMovedNotification",
	5: "HostPunchNotification",
	6: "HostWhoami",
	7: "HostWhoamiReply",
	8: "PathCheck",
	9: "PathCheckReply",
}

var NebulaMeta_MessageType_value = map[string]int32{
	"None":                   0,
	"HostQuery":              1,
	"HostQueryReply":         2,
	"HostUpdateNotification": 3,
	"HostMovedNotification":  4,
	"HostPunchNotification":  5,
	"HostWhoami":             6,
	"HostWhoamiReply":        7,
	"PathCheck":              8,
	"PathCheckReply":         9,
}

func (x NebulaMeta_MessageType) String() string {
	return proto.EnumName(NebulaMeta_MessageType_name, int32(x))
}

func (NebulaMeta_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{0, 0}
}

type NebulaPing_MessageType int32

const (
	NebulaPing_Ping  NebulaPing_MessageType = 0
	NebulaPing_Reply NebulaPing_MessageType = 1
)

var NebulaPing_MessageType_name = map[int32]string{
	0: "Ping",
	1: "Reply",
}

var NebulaPing_MessageType_value = map[string]int32{
	"Ping":  0,
	"Reply": 1,
}

func (x NebulaPing_MessageType) String() string {
	return proto.EnumName(NebulaPing_MessageType_name, int32(x))
}

func (NebulaPing_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{5, 0}
}

type NebulaControl_MessageType int32

const (
	NebulaControl_None                NebulaControl_MessageType = 0
	NebulaControl_CreateRelayRequest  NebulaControl_MessageType = 1
	NebulaControl_CreateRelayResponse NebulaControl_MessageType = 2
	NebulaControl_RemoveRelayRequest  NebulaControl_MessageType = 3
)

var NebulaControl_MessageType_name = map[int32]string{
	0: "None",
	1: "CreateRelayRequest",
	2: "CreateRelayResponse",
	3: "RemoveRelayRequest",
}

var NebulaControl_MessageType_value = map[string]int32{
	"None":                0,
	"CreateRelayRequest":  1,
	"CreateRelayResponse": 2,
	"RemoveRelayRequest":  3,
}

func (x NebulaControl_MessageType) String() string {
	return proto.EnumName(NebulaControl_MessageType_name, int32(x))
}

func (NebulaControl_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{8, 0}
}

type NebulaMeta struct {
	Type    NebulaMeta_MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=nebula.NebulaMeta_MessageType" json:"Type,omitempty"`
	Details *NebulaMetaDetails     `protobuf:"bytes,2,opt,name=Details,proto3" json:"Details,omitempty"`
}

func (m *NebulaMeta) Reset()         { *m = NebulaMeta{} }
func (m *NebulaMeta) String() string { return proto.CompactTextString(m) }
func (*NebulaMeta) ProtoMessage()    {}
func (*NebulaMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{0}
}
func (m *NebulaMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaMeta.Merge(m, src)
}
func (m *NebulaMeta) XXX_Size() int {
	return m.Size()
}
func (m *NebulaMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaMeta.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaMeta proto.InternalMessageInfo

func (m *NebulaMeta) GetType() NebulaMeta_MessageType {
	if m != nil {
		return m.Type
	}
	return NebulaMeta_None
}

func (m *NebulaMeta) GetDetails() *NebulaMetaDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

type NebulaMetaDetails struct {
	VpnIp       uint32        `protobuf:"varint,1,opt,name=VpnIp,proto3" json:"VpnIp,omitempty"`
	Ip4AndPorts []*Ip4AndPort `protobuf:"bytes,2,rep,name=Ip4AndPorts,proto3" json:"Ip4AndPorts,omitempty"`
	Ip6AndPorts []*Ip6AndPort `protobuf:"bytes,4,rep,name=Ip6AndPorts,proto3" json:"Ip6AndPorts,omitempty"`
	RelayVpnIp  []uint32      `protobuf:"varint,6,rep,packed,name=RelayVpnIp,proto3" json:"RelayVpnIp,omitempty"`
	Counter     uint32        `protobuf:"varint,3,opt,name=counter,proto3" json:"counter,omitempty"`
}

func (m *NebulaMetaDetails) Reset()         { *m = NebulaMetaDetails{} }
func (m *NebulaMetaDetails) String() string { return proto.CompactTextString(m) }
func (*NebulaMetaDetails) ProtoMessage()    {}
func (*NebulaMetaDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{1}
}
func (m *NebulaMetaDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaMetaDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaMetaDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaMetaDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaMetaDetails.Merge(m, src)
}
func (m *NebulaMetaDetails) XXX_Size() int {
	return m.Size()
}
func (m *NebulaMetaDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaMetaDetails.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaMetaDetails proto.InternalMessageInfo

func (m *NebulaMetaDetails) GetVpnIp() uint32 {
	if m != nil {
		return m.VpnIp
	}
	return 0
}

func (m *NebulaMetaDetails) GetIp4AndPorts() []*Ip4AndPort {
	if m != nil {
		return m.Ip4AndPorts
	}
	return nil
}

func (m *NebulaMetaDetails) GetIp6AndPorts() []*Ip6AndPort {
	if m != nil {
		return m.Ip6AndPorts
	}
	return nil
}

func (m *NebulaMetaDetails) GetRelayVpnIp() []uint32 {
	if m != nil {
		return m.RelayVpnIp
	}
	return nil
}

func (m *NebulaMetaDetails) GetCounter() uint32 {
	if m != nil {
		return m.Counter
	}
	return 0
}

type Ip4AndPort struct {
	Ip   uint32 `protobuf:"varint,1,opt,name=Ip,proto3" json:"Ip,omitempty"`
	Port uint32 `protobuf:"varint,2,opt,name=Port,proto3" json:"Port,omitempty"`
}

func (m *Ip4AndPort) Reset()         { *m = Ip4AndPort{} }
func (m *Ip4AndPort) String() string { return proto.CompactTextString(m) }
func (*Ip4AndPort) ProtoMessage()    {}
func (*Ip4AndPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{2}
}
func (m *Ip4AndPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ip4AndPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ip4AndPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ip4AndPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ip4AndPort.Merge(m, src)
}
func (m *Ip4AndPort) XXX_Size() int {
	return m.Size()
}
func (m *Ip4AndPort) XXX_DiscardUnknown() {
	xxx_messageInfo_Ip4AndPort.DiscardUnknown(m)
}

var xxx_messageInfo_Ip4AndPort proto.InternalMessageInfo

func (m *Ip4AndPort) GetIp() uint32 {
	if m != nil {
		return m.Ip
	}
	return 0
}

func (m *Ip4AndPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Ip6AndPort struct {
	Hi   uint64 `protobuf:"varint,1,opt,name=Hi,proto3" json:"Hi,omitempty"`
	Lo   uint64 `protobuf:"varint,2,opt,name=Lo,proto3" json:"Lo,omitempty"`
	Port uint32 `protobuf:"varint,3,opt,name=Port,proto3" json:"Port,omitempty"`
}

func (m *Ip6AndPort) Reset()         { *m = Ip6AndPort{} }
func (m *Ip6AndPort) String() string { return proto.CompactTextString(m) }
func (*Ip6AndPort) ProtoMessage()    {}
func (*Ip6AndPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{3}
}
func (m *Ip6AndPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ip6AndPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ip6AndPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ip6AndPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ip6AndPort.Merge(m, src)
}
func (m *Ip6AndPort) XXX_Size() int {
	return m.Size()
}
func (m *Ip6AndPort) XXX_DiscardUnknown() {
	xxx_messageInfo_Ip6AndPort.DiscardUnknown(m)
}

var xxx_messageInfo_Ip6AndPort proto.InternalMessageInfo

func (m *Ip6AndPort) GetHi() uint64 {
	if m != nil {
		return m.Hi
	}
	return 0
}

func (m *Ip6AndPort) GetLo() uint64 {
	if m != nil {
		return m.Lo
	}
	return 0
}

func (m *Ip6AndPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Ip4CIDR struct {
	Ip   uint32 `protobuf:"varint,1,opt,name=Ip,proto3" json:"Ip,omitempty"`
	Mask uint32 `protobuf:"varint,2,opt,name=Mask,proto3" json:"Mask,omitempty"`
}

func (m *Ip4CIDR) Reset()         { *m = Ip4CIDR{} }
func (m *Ip4CIDR) String() string { return proto.CompactTextString(m) }
func (*Ip4CIDR) ProtoMessage()    {}
func (*Ip4CIDR) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{4}
}
func (m *Ip4CIDR) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ip4CIDR) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ip4CIDR.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ip4CIDR) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ip4CIDR.Merge(m, src)
}
func (m *Ip4CIDR) XXX_Size() int {
	return m.Size()
}
func (m *Ip4CIDR) XXX_DiscardUnknown() {
	xxx_messageInfo_Ip4CIDR.DiscardUnknown(m)
}

var xxx_messageInfo_Ip4CIDR proto.InternalMessageInfo

func (m *Ip4CIDR) GetIp() uint32 {
	if m != nil {
		return m.Ip
	}
	return 0
}

func (m *Ip4CIDR) GetMask() uint32 {
	if m != nil {
		return m.Mask
	}
	return 0
}

type NebulaPing struct {
	Type NebulaPing_MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=nebula.NebulaPing_MessageType" json:"Type,omitempty"`
	Time uint64                 `protobuf:"varint,2,opt,name=Time,proto3" json:"Time,omitempty"`
}

func (m *NebulaPing) Reset()         { *m = NebulaPing{} }
func (m *NebulaPing) String() string { return proto.CompactTextString(m) }
func (*NebulaPing) ProtoMessage()    {}
func (*NebulaPing) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{5}
}
func (m *NebulaPing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaPing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaPing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaPing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaPing.Merge(m, src)
}
func (m *NebulaPing) XXX_Size() int {
	return m.Size()
}
func (m *NebulaPing) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaPing.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaPing proto.InternalMessageInfo

func (m *NebulaPing) GetType() NebulaPing_MessageType {
	if m != nil {
		return m.Type
	}
	return NebulaPing_Ping
}

func (m *NebulaPing) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type NebulaHandshake struct {
	Details *NebulaHandshakeDetails `protobuf:"bytes,1,opt,name=Details,proto3" json:"Details,omitempty"`
	Hmac    []byte                  `protobuf:"bytes,2,opt,name=Hmac,proto3" json:"Hmac,omitempty"`
}

func (m *NebulaHandshake) Reset()         { *m = NebulaHandshake{} }
func (m *NebulaHandshake) String() string { return proto.CompactTextString(m) }
func (*NebulaHandshake) ProtoMessage()    {}
func (*NebulaHandshake) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{6}
}
func (m *NebulaHandshake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaHandshake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaHandshake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaHandshake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaHandshake.Merge(m, src)
}
func (m *NebulaHandshake) XXX_Size() int {
	return m.Size()
}
func (m *NebulaHandshake) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaHandshake.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaHandshake proto.InternalMessageInfo

func (m *NebulaHandshake) GetDetails() *NebulaHandshakeDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *NebulaHandshake) GetHmac() []byte {
	if m != nil {
		return m.Hmac
	}
	return nil
}

type NebulaHandshakeDetails struct {
	Cert           []byte `protobuf:"bytes,1,opt,name=Cert,proto3" json:"Cert,omitempty"`
	InitiatorIndex uint32 `protobuf:"varint,2,opt,name=InitiatorIndex,proto3" json:"InitiatorIndex,omitempty"`
	ResponderIndex uint32 `protobuf:"varint,3,opt,name=ResponderIndex,proto3" json:"ResponderIndex,omitempty"`
	Cookie         uint64 `protobuf:"varint,4,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	Time           uint64 `protobuf:"varint,5,opt,name=Time,proto3" json:"Time,omitempty"`
}

func (m *NebulaHandshakeDetails) Reset()         { *m = NebulaHandshakeDetails{} }
func (m *NebulaHandshakeDetails) String() string { return proto.CompactTextString(m) }
func (*NebulaHandshakeDetails) ProtoMessage()    {}
func (*NebulaHandshakeDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{7}
}
func (m *NebulaHandshakeDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaHandshakeDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaHandshakeDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaHandshakeDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaHandshakeDetails.Merge(m, src)
}
func (m *NebulaHandshakeDetails) XXX_Size() int {
	return m.Size()
}
func (m *NebulaHandshakeDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaHandshakeDetails.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaHandshakeDetails proto.InternalMessageInfo

func (m *NebulaHandshakeDetails) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *NebulaHandshakeDetails) GetInitiatorIndex() uint32 {
	if m != nil {
		return m.InitiatorIndex
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetResponderIndex() uint32 {
	if m != nil {
		return m.ResponderIndex
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetCookie() uint64 {
	if m != nil {
		return m.Cookie
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type NebulaControl struct {
	Type                NebulaControl_MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=nebula.NebulaControl_MessageType" json:"Type,omitempty"`
	InitiatorRelayIndex uint32                    `protobuf:"varint,2,opt,name=InitiatorRelayIndex,proto3" json:"InitiatorRelayIndex,omitempty"`
	ResponderRelayIndex uint32                    `protobuf:"varint,3,opt,name=ResponderRelayIndex,proto3" json:"ResponderRelayIndex,omitempty"`
	RelayToIp           uint32                    `protobuf:"varint,4,opt,name=RelayToIp,proto3" json:"RelayToIp,omitempty"`
	RelayFromIp         uint32                    `protobuf:"varint,5,opt,name=RelayFromIp,proto3" json:"RelayFromIp,omitempty"`
}

func (m *NebulaControl) Reset()         { *m = NebulaControl{} }
func (m *NebulaControl) String() string { return proto.CompactTextString(m) }
func (*NebulaControl) ProtoMessage()    {}
func (*NebulaControl) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{8}
}
func (m *NebulaControl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaControl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaControl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaControl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaControl.Merge(m, src)
}
func (m *NebulaControl) XXX_Size() int {
	return m.Size()
}
func (m *NebulaControl) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaControl.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaControl proto.InternalMessageInfo

func (m *NebulaControl) GetType() NebulaControl_MessageType {
	if m != nil {
		return m.Type
	}
	return NebulaControl_None
}

func (m *NebulaControl) GetInitiatorRelayIndex() uint32 {
	if m != nil {
		return m.InitiatorRelayIndex
	}
	return 0
}

func (m *NebulaControl) GetResponderRelayIndex() uint32 {
	if m != nil {
		return m.ResponderRelayIndex
	}
	return 0
}

func (m *NebulaControl) GetRelayToIp() uint32 {
	if m != nil {
		return m.RelayToIp
	}
	return 0
}

func (m *NebulaControl) GetRelayFromIp() uint32 {
	if m != nil {
		return m.RelayFromIp
	}
	return 0
}

func init() {
	proto.RegisterEnum("nebula.NebulaMeta_MessageType", NebulaMeta_MessageType_name, NebulaMeta_MessageType_value)
	proto.RegisterEnum("nebula.NebulaPing_MessageType", NebulaPing_MessageType_name, NebulaPing_MessageType_value)
	proto.RegisterEnum("nebula.NebulaControl_MessageType", NebulaControl_MessageType_name, NebulaControl_MessageType_value)
	proto.RegisterType((*NebulaMeta)(nil), "nebula.NebulaMeta")
	proto.RegisterType((*NebulaMetaDetails)(nil), "nebula.NebulaMetaDetails")
	proto.RegisterType((*Ip4AndPort)(nil), "nebula.Ip4AndPort")
	proto.RegisterType((*Ip6AndPort)(nil), "nebula.Ip6AndPort")
	proto.RegisterType((*Ip4CIDR)(nil), "nebula.Ip4CIDR")
	proto.RegisterType((*NebulaPing)(nil), "nebula.NebulaPing")
	proto.RegisterType((*NebulaHandshake)(nil), "nebula.NebulaHandshake")
	proto.RegisterType((*NebulaHandshakeDetails)(nil), "nebula.NebulaHandshakeDetails")
	proto.RegisterType((*NebulaControl)(nil), "nebula.NebulaControl")
}

func init() { proto.RegisterFile("nebula.proto", fileDescriptor_2d65afa7693df5ef) }

var fileDescriptor_2d65afa7693df5ef = []byte{
	// 712 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xcd, 0x6e, 0xda, 0x4c,
	0x14, 0xc5, 0xc6, 0x40, 0xb8, 0x04, 0xe2, 0xef, 0xe6, 0x2b, 0x25, 0x55, 0x65, 0x51, 0x2f, 0x2a,
	0x36, 0x25, 0x11, 0x49, 0xa3, 0x2e, 0xdb, 0x12, 0x55, 0x58, 0x0a, 0x11, 0x1d, 0xa5, 0xad, 0xd4,
	0x4d, 0x3b, 0x81, 0x69, 0xb0, 0x00, 0x8f, 0x63, 0x0f, 0x51, 0x78, 0x8b, 0x3e, 0x46, 0x1f, 0xa5,
	0x8b, 0x48, 0xcd, 0xa2, 0x8b, 0x2e, 0xab, 0xe4, 0x45, 0xaa, 0x19, 0x1b, 0x63, 0x08, 0xed, 0xee,
	0xfe, 0x9c, 0x33, 0x73, 0xee, 0x99, 0x6b, 0xc3, 0xa6, 0xc7, 0xce, 0xa6, 0x63, 0xda, 0xf4, 0x03,
	0x2e, 0x38, 0xe6, 0xa3, 0xcc, 0xbe, 0xd6, 0x01, 0x4e, 0x54, 0xd8, 0x65, 0x82, 0x62, 0x0b, 0x8c,
	0xd3, 0x99, 0xcf, 0x6a, 0x5a, 0x5d, 0x6b, 0x54, 0x5a, 0x56, 0x33, 0xe6, 0x2c, 0x10, 0xcd, 0x2e,
	0x0b, 0x43, 0x7a, 0xce, 0x24, 0x8a, 0x28, 0x2c, 0xee, 0x43, 0xe1, 0x88, 0x09, 0xea, 0x8e, 0xc3,
	0x9a, 0x5e, 0xd7, 0x1a, 0xa5, 0xd6, 0xce, 0x7d, 0x5a, 0x0c, 0x20, 0x73, 0xa4, 0xfd, 0x53, 0x83,
	0x52, 0xea, 0x28, 0xdc, 0x00, 0xe3, 0x84, 0x7b, 0xcc, 0xcc, 0x60, 0x19, 0x8a, 0x1d, 0x1e, 0x8a,
	0xb7, 0x53, 0x16, 0xcc, 0x4c, 0x0d, 0x11, 0x2a, 0x49, 0x4a, 0x98, 0x3f, 0x9e, 0x99, 0x3a, 0x3e,
	0x82, 0xaa, 0xac, 0xbd, 0xf3, 0x07, 0x54, 0xb0, 0x13, 0x2e, 0xdc, 0x2f, 0x6e, 0x9f, 0x0a, 0x97,
	0x7b, 0x66, 0x16, 0x77, 0xe0, 0x81, 0xec, 0x75, 0xf9, 0x25, 0x1b, 0x2c, 0xb5, 0x8c, 0x79, 0xab,
	0x37, 0xf5, 0xfa, 0xc3, 0xa5, 0x56, 0x0e, 0x2b, 0x00, 0xb2, 0xf5, 0x61, 0xc8, 0xe9, 0xc4, 0x35,
	0xf3, 0xb8, 0x0d, 0x5b, 0x8b, 0x3c, 0xba, 0xb6, 0x20, 0x95, 0xf5, 0xa8, 0x18, 0xb6, 0x87, 0xac,
	0x3f, 0x32, 0x37, 0xa4, 0xb2, 0x24, 0x8d, 0x20, 0x45, 0xfb, 0x87, 0x06, 0xff, 0xdd, 0x9b, 0x1a,
	0xff, 0x87, 0xdc, 0x7b, 0xdf, 0x73, 0x7c, 0x65, 0x6b, 0x99, 0x44, 0x09, 0x1e, 0x40, 0xc9, 0xf1,
	0x0f, 0x5e, 0x79, 0x83, 0x1e, 0x0f, 0x84, 0xf4, 0x2e, 0xdb, 0x28, 0xb5, 0x70, 0xee, 0xdd, 0xa2,
	0x45, 0xd2, 0xb0, 0x88, 0x75, 0x98, 0xb0, 0x8c, 0x55, 0xd6, 0x61, 0x8a, 0x95, 0xc0, 0xd0, 0x02,
	0x20, 0x6c, 0x4c, 0x67, 0x91, 0x8c, 0x7c, 0x3d, 0xdb, 0x28, 0x93, 0x54, 0x05, 0x6b, 0x50, 0xe8,
	0xf3, 0xa9, 0x27, 0x58, 0x50, 0xcb, 0x2a, 0x8d, 0xf3, 0xd4, 0xde, 0x03, 0x58, 0x5c, 0x8f, 0x15,
	0xd0, 0x93, 0x31, 0x74, 0xc7, 0x47, 0x04, 0x43, 0xd6, 0xd5, 0xc3, 0x97, 0x89, 0x8a, 0xed, 0x97,
	0x92, 0x71, 0x98, 0x62, 0x74, 0x5c, 0xc5, 0x30, 0x88, 0xde, 0x71, 0x65, 0x7e, 0xcc, 0x15, 0xde,
	0x20, 0xfa, 0x31, 0x4f, 0x4e, 0xc8, 0xa6, 0x4e, 0x78, 0x06, 0x05, 0xc7, 0x3f, 0x68, 0x3b, 0x47,
	0x64, 0xdd, 0x85, 0x5d, 0x1a, 0x8e, 0xe6, 0x17, 0xca, 0xd8, 0xbe, 0x9a, 0xaf, 0x70, 0xcf, 0xf5,
	0xce, 0xff, 0xbd, 0xc2, 0x12, 0xb1, 0x66, 0x85, 0x11, 0x8c, 0x53, 0x77, 0xc2, 0x62, 0x59, 0x2a,
	0xb6, 0xed, 0x7b, 0x0b, 0x2a, 0xc9, 0x66, 0x06, 0x8b, 0x90, 0x8b, 0x9e, 0x5b, 0xb3, 0x3f, 0xc1,
	0x56, 0x74, 0x6e, 0x87, 0x7a, 0x83, 0x70, 0x48, 0x47, 0x0c, 0x5f, 0x2c, 0xbe, 0x06, 0x4d, 0x7d,
	0x0d, 0x2b, 0x0a, 0x12, 0xe4, 0xea, 0x27, 0x21, 0x45, 0x74, 0x26, 0xb4, 0xaf, 0x44, 0x6c, 0x12,
	0x15, 0xdb, 0xdf, 0x34, 0xa8, 0xae, 0xe7, 0x49, 0x78, 0x9b, 0x05, 0x42, 0xdd, 0xb2, 0x49, 0x54,
	0x8c, 0x4f, 0xa1, 0xe2, 0x78, 0xae, 0x70, 0xa9, 0xe0, 0x81, 0xe3, 0x0d, 0xd8, 0x55, 0xec, 0xd3,
	0x4a, 0x55, 0xe2, 0x08, 0x0b, 0x7d, 0xee, 0x0d, 0x58, 0x8c, 0x8b, 0xec, 0x5f, 0xa9, 0x62, 0x15,
	0xf2, 0x6d, 0xce, 0x47, 0x2e, 0xab, 0x19, 0xca, 0x99, 0x38, 0x4b, 0xfc, 0xca, 0xa5, 0xfc, 0xba,
	0xd6, 0xa1, 0x1c, 0x49, 0x6d, 0x73, 0x4f, 0x04, 0x7c, 0x8c, 0xcf, 0x97, 0x5e, 0xe2, 0xc9, 0xb2,
	0x0f, 0x31, 0x68, 0xcd, 0x63, 0xec, 0xc1, 0x76, 0x22, 0x57, 0xad, 0x68, 0x7a, 0x92, 0x75, 0x2d,
	0xc9, 0x48, 0x84, 0xa7, 0x18, 0xd1, 0x4c, 0xeb, 0x5a, 0xf8, 0x18, 0x8a, 0x2a, 0x3b, 0xe5, 0x8e,
	0xaf, 0x66, 0x2b, 0x93, 0x45, 0x01, 0xeb, 0x50, 0x52, 0xc9, 0x9b, 0x80, 0x4f, 0x1c, 0x5f, 0x4d,
	0x59, 0x26, 0xe9, 0x92, 0xfd, 0xf9, 0x6f, 0x7f, 0xaf, 0x2a, 0x60, 0x3b, 0x60, 0x54, 0x30, 0x85,
	0x26, 0xec, 0x62, 0xca, 0x42, 0x61, 0x6a, 0xf8, 0x10, 0xb6, 0x97, 0xea, 0x52, 0x52, 0xc8, 0x4c,
	0x5d, 0x12, 0x08, 0x9b, 0xf0, 0xcb, 0x65, 0x42, 0xf6, 0xf5, 0xfe, 0xf7, 0x5b, 0x4b, 0xbb, 0xb9,
	0xb5, 0xb4, 0xdf, 0xb7, 0x96, 0xf6, 0xf5, 0xce, 0xca, 0xdc, 0xdc, 0x59, 0x99, 0x5f, 0x77, 0x56,
	0xe6, 0xe3, 0xce, 0xb9, 0x2b, 0x86, 0xd3, 0xb3, 0x66, 0x9f, 0x4f, 0x76, 0xc3, 0x31, 0xed, 0x8f,
	0x86, 0x17, 0xbb, 0x91, 0xb5, 0x67, 0x79, 0xf5, 0x73, 0xdf, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff,
	0x9d, 0xf7, 0x82, 0xc1, 0xec, 0x05, 0x00, 0x00,
}

func (m *NebulaMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NebulaMetaDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaMetaDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaMetaDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RelayVpnIp) > 0 {
		dAtA3 := make([]byte, len(m.RelayVpnIp)*10)
		var j2 int
		for _, num := range m.RelayVpnIp {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintNebula(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Ip6AndPorts) > 0 {
		for iNdEx := len(m.Ip6AndPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ip6AndPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNebula(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Counter != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Counter))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ip4AndPorts) > 0 {
		for iNdEx := len(m.Ip4AndPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ip4AndPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNebula(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.VpnIp != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.VpnIp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Ip4AndPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ip4AndPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ip4AndPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if m.Ip != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Ip))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Ip6AndPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ip6AndPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ip6AndPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if m.Lo != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Lo))
		i--
		dAtA[i] = 0x10
	}
	if m.Hi != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Hi))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Ip4CIDR) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ip4CIDR) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ip4CIDR) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mask != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Mask))
		i--
		dAtA[i] = 0x10
	}
	if m.Ip != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Ip))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NebulaPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaPing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaPing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NebulaHandshake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaHandshake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaHandshake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hmac) > 0 {
		i -= len(m.Hmac)
		copy(dAtA[i:], m.Hmac)
		i = encodeVarintNebula(dAtA, i, uint64(len(m.Hmac)))
		i--
		dAtA[i] = 0x12
	}
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NebulaHandshakeDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaHandshakeDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaHandshakeDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x28
	}
	if m.Cookie != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Cookie))
		i--
		dAtA[i] = 0x20
	}
	if m.ResponderIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.ResponderIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.InitiatorIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.InitiatorIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintNebula(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NebulaControl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaControl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaControl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RelayFromIp != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.RelayFromIp))
		i--
		dAtA[i] = 0x28
	}
	if m.RelayToIp != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.RelayToIp))
		i--
		dAtA[i] = 0x20
	}
	if m.ResponderRelayIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.ResponderRelayIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.InitiatorRelayIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.InitiatorRelayIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNebula(dAtA []byte, offset int, v uint64) int {
	offset -= sovNebula(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NebulaMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNebula(uint64(m.Type))
	}
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	return n
}

func (m *NebulaMetaDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VpnIp != 0 {
		n += 1 + sovNebula(uint64(m.VpnIp))
	}
	if len(m.Ip4AndPorts) > 0 {
		for _, e := range m.Ip4AndPorts {
			l = e.Size()
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if m.Counter != 0 {
		n += 1 + sovNebula(uint64(m.Counter))
	}
	if len(m.Ip6AndPorts) > 0 {
		for _, e := range m.Ip6AndPorts {
			l = e.Size()
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if len(m.RelayVpnIp) > 0 {
		l = 0
		for _, e := range m.RelayVpnIp {
			l += sovNebula(uint64(e))
		}
		n += 1 + sovNebula(uint64(l)) + l
	}
	return n
}

func (m *Ip4AndPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != 0 {
		n += 1 + sovNebula(uint64(m.Ip))
	}
	if m.Port != 0 {
		n += 1 + sovNebula(uint64(m.Port))
	}
	return n
}

func (m *Ip6AndPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hi != 0 {
		n += 1 + sovNebula(uint64(m.Hi))
	}
	if m.Lo != 0 {
		n += 1 + sovNebula(uint64(m.Lo))
	}
	if m.Port != 0 {
		n += 1 + sovNebula(uint64(m.Port))
	}
	return n
}

func (m *Ip4CIDR) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != 0 {
		n += 1 + sovNebula(uint64(m.Ip))
	}
	if m.Mask != 0 {
		n += 1 + sovNebula(uint64(m.Mask))
	}
	return n
}

func (m *NebulaPing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNebula(uint64(m.Type))
	}
	if m.Time != 0 {
		n += 1 + sovNebula(uint64(m.Time))
	}
	return n
}

func (m *NebulaHandshake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	l = len(m.Hmac)
	if l > 0 {
		n += 1 + l + sovNebula(uint64(l))
	}
	return n
}

func (m *NebulaHandshakeDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovNebula(uint64(l))
	}
	if m.InitiatorIndex != 0 {
		n += 1 + sovNebula(uint64(m.InitiatorIndex))
	}
	if m.ResponderIndex != 0 {
		n += 1 + sovNebula(uint64(m.ResponderIndex))
	}
	if m.Cookie != 0 {
		n += 1 + sovNebula(uint64(m.Cookie))
	}
	if m.Time != 0 {
		n += 1 + sovNebula(uint64(m.Time))
	}
	return n
}

func (m *NebulaControl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNebula(uint64(m.Type))
	}
	if m.InitiatorRelayIndex != 0 {
		n += 1 + sovNebula(uint64(m.InitiatorRelayIndex))
	}
	if m.ResponderRelayIndex != 0 {
		n += 1 + sovNebula(uint64(m.ResponderRelayIndex))
	}
	if m.RelayToIp != 0 {
		n += 1 + sovNebula(uint64(m.RelayToIp))
	}
	if m.RelayFromIp != 0 {
		n += 1 + sovNebula(uint64(m.RelayFromIp))
	}
	return n
}

func sovNebula(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNebula(x uint64) (n int) {
	return sovNebula(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NebulaMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NebulaMeta_MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &NebulaMetaDetails{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaMetaDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaMetaDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaMetaDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpnIp", wireType)
			}
			m.VpnIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VpnIp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip4AndPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip4AndPorts = append(m.Ip4AndPorts, &Ip4AndPort{})
			if err := m.Ip4AndPorts[len(m.Ip4AndPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			m.Counter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Counter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip6AndPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip6AndPorts = append(m.Ip6AndPorts, &Ip6AndPort{})
			if err := m.Ip6AndPorts[len(m.Ip6AndPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNebula
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RelayVpnIp = append(m.RelayVpnIp, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNebula
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNebula
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNebula
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RelayVpnIp) == 0 {
					m.RelayVpnIp = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNebula
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RelayVpnIp = append(m.RelayVpnIp, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayVpnIp", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ip4AndPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ip4AndPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ip4AndPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			m.Ip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ip |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ip6AndPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ip6AndPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ip6AndPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hi", wireType)
			}
			m.Hi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hi |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lo", wireType)
			}
			m.Lo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Lo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ip4CIDR) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ip4CIDR: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ip4CIDR: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			m.Ip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ip |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mask", wireType)
			}
			m.Mask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mask |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NebulaPing_MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaHandshake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaHandshake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaHandshake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &NebulaHandshakeDetails{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hmac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hmac = append(m.Hmac[:0], dAtA[iNdEx:postIndex]...)
			if m.Hmac == nil {
				m.Hmac = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaHandshakeDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaHandshakeDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaHandshakeDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorIndex", wireType)
			}
			m.InitiatorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitiatorIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponderIndex", wireType)
			}
			m.ResponderIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponderIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			m.Cookie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cookie |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaControl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaControl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaControl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NebulaControl_MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorRelayIndex", wireType)
			}
			m.InitiatorRelayIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitiatorRelayIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponderRelayIndex", wireType)
			}
			m.ResponderRelayIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponderRelayIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayToIp", wireType)
			}
			m.RelayToIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelayToIp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayFromIp", wireType)
			}
			m.RelayFromIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RelayFromIp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNebula(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNebula
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNebula
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNebula
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNebula        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNebula          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNebula = fmt.Errorf("proto: unexpected end of group")
)
